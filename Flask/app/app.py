#Imports
from flask import Flask, render_template, redirect, url_for, request, session, flash, g, Response
from functools import wraps
from flask_mail import Mail, Message
from datetime import date,datetime
from flask.ext.triangle import Triangle
from itsdangerous import URLSafeTimedSerializer
from werkzeug import secure_filename
import math

import bcrypt
import os
import pymysql

from flask.ext.socketio import emit, join_room, leave_room
from flask.ext.socketio import SocketIO
#app creation
app = Flask(__name__,  static_folder = 'static')
mail = Mail(app)
Triangle(app)
socketio = SocketIO(app)

#email configuration
app.config.update(
	DEBUG=True,

	#EMAIL SETTINGS
	MAIL_SERVER='smtp.gmail.com',
	MAIL_PORT=465,
	MAIL_USE_SSL=True,
	MAIL_USERNAME = 'hoppa.notifications@gmail.com',
	MAIL_PASSWORD = 'spamnotifications'
)
mail=Mail(app)

#Random secret key generated by OS
app.config['SECRET_KEY'] = 'B\xe5\x1cN\x90k\xb6\x0c\x08\x1f\x05\xb7t\xfd\xb3\xee\xa5$*\xf0\xe9\xbb\x8e\xbd'
app.config['SECURITY_PASSWORD_SALT'] = 'so_secret'

ts = URLSafeTimedSerializer(app.config['SECRET_KEY'])

UPLOAD_FOLDER = 'static'
ALLOWED_EXTENSIONS = set(['png', 'jpg', 'jpeg'])

app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER

@app.route('/message', methods=['GET','POST'])
def message():
	getfriends = "SELECT * FROM db_hoppa.friends WHERE me='%d';" % (theuserid)
	
	try:
		cur.execute(getfriends)
		friends = [dict(friend_id=row[0], username = row[1], fuser_id=row[3]) for row in cur.fetchall()]
		
	except pymysql.InternalError:
		error = "Error adding the data. Please try again."
#  	new_im = "INSERT INTO db_hoppa.messages (sender_id, receiver_id) VALUES ('%s', '%s');" % (theuserid, user_phoneuser)
		# try:
		# 	if not is_in:
		# 		cur.execute(new_im)
		# 		hoppa.commit()					
		# except pymysql.InternalError:
		# 	error = "Error adding the data. Please try again."



    	if request.method == 'POST':
    		print(request.form['chat'])
    		global theidofthefriend
    		theidofthefriend = request.form['chat']
    		return redirect('im') 

    	return render_template('message.html', friends = friends)

@app.route('/im', methods=['GET','POST'])
def chat():
	
	getmyname = "SELECT * FROM db_hoppa.hoppers WHERE user_id='%d';" % (theuserid)
	print(getmyname)
	cur.execute(getmyname)

	name = [dict(username = row[3]) for row in cur.fetchall()]

	session['name'] = name[0]['username']
	sub = int(theuserid) - int(theidofthefriend)
	session['room'] = abs(sub)
	print (abs(sub))

	name = session.get('name')
	room = session.get('room')

    	return render_template('im.html', name=name, room=room)

@socketio.on('joined', namespace='/im')
def joined(message):
    """Sent by clients when they enter a room.
    A status message is broadcast to all people in the room."""
    room = session.get('room')
    join_room(room)
    emit('status', {'msg': session.get('name') + ' is online. Hop!! Now you can chat!'}, room=room)


@socketio.on('text', namespace='/im')
def left(message):
    """Sent by a client when the user entered a new message.
    The message is sent to all people in the room."""
    room = session.get('room')
    emit('message', {'msg': session.get('name') + ':' + message['msg']}, room=room)


@socketio.on('left', namespace='/im')
def left(message):
    """Sent by clients when they leave a room.
    A status message is broadcast to all people in the room."""
    room = session.get('room')
    leave_room(room)
    emit('status', {'msg': session.get('name') + ' is offline. '}, room=room)

def allowed_file(filename):
	return '.' in filename and filename.rsplit('.', 1)[1] in ALLOWED_EXTENSIONS

def upload_file():
	if request.method == 'POST':
		print("ESTOY EN UPLOAD")
		file = request.files['file']

		if file and allowed_file(file.filename):
			filename = secure_filename(file.filename)
			pic_directory = os.path.join(app.config['UPLOAD_FOLDER'], filename)
			print(pic_directory)
			file.save(pic_directory)
			print (pic_directory)
			# pic_directory = pic_directory.split("/")
			# filename = pic_directory[2]
			return filename
	return None
	# Esto se puede poner en cualquier html donde se vaya a subir alguna foto:
    # <form action="" method=post enctype=multipart/form-data>
    #   <p><input type=file name=file>
    #      <input type=submit value=Upload></p>
    # </form>


def login_required(f):
	@wraps(f)
	def wrap(*args, **kwargs):
		if 'logged_in' in session:
			return f(*args, **kwargs)
		else:
			flash('Please login.')
			return redirect(url_for('login'))
	return wrap

@app.route('/')
@login_required
def home():
	return render_template('welcome.html')

@app.route('/login', methods=['GET','POST'])
def login():
	error = None

	if request.method == 'POST':
		global hoppa, cur

		hoppa = pymysql.connect(host='br-cdbr-azure-south-a.cloudapp.net', port=3306, user='b15b0d9651d904', passwd='97022638', db='db_hoppa')
		cur = hoppa.cursor()

		#user credentials
		useremail = request.form['useremail'].strip()
		password = request.form['password'].strip()

		#get user data from DB
		users_credentials = "SELECT * FROM db_hoppa.hoppers;"

		try:
			cur.execute(users_credentials)

			users = [dict(userid= row[0], useremail=row[1], password=row[7], userfirst=row[3], userlast=row[4], usermiddle=row[5], confirmed=row[10], userrank=row[9], usertype=row[8]) for row in cur.fetchall()]

			#user authentication
			if users:
				for row in users:

					pw_bytes = password.encode('utf-8') #encoding the password for security reasons

					if row['useremail'] == useremail and bcrypt.hashpw(pw_bytes, row['password']) == row['password'] and row['confirmed'] == 1:
						session['logged_in'] = True

						global theuserid
						theuserid = row['userid']

						global theuseremail
						theuseremail = row['useremail']

						global theuserrank
						theuserrank = row['userrank']

						global theusername
						if row['usermiddle']:
							theusername = row['userfirst'] + " " + row['usermiddle'] + " " + row['userlast']
						else:
							theusername = row['userfirst'] + " " + row['userlast']

						global theusertype
						theusertype = row['usertype']

						select_profile = "SELECT * FROM db_hoppa.user_profile;"
						empty_profile = "INSERT INTO db_hoppa.user_profile (user_about, user_interests, user_association, user_courses, owner_p) VALUES (' ', ' ' , ' ', ' ', '%d');" % (theuserid)
						empty_education = "INSERT INTO db_hoppa.education (school_name, major,eduser_id) VALUES (' ', ' ', '%d');" % (theuserid)

						try:
							cur.execute(select_profile)

							data = [dict(ownerid=row[6]) for row in cur.fetchall()]

							have_profile = False

							for row in data:
								if row['ownerid'] == theuserid:
									have_profile = True

							if not have_profile:	
								cur.execute(empty_profile)
								hoppa.commit()

								cur.execute(empty_education)
								hoppa.commit()
						except pymysql.InternalError:
							error = "No profile information was fetched."

						flash("Welcome to Hoppa!")
						return redirect(url_for('newsfeed'))
					elif row['useremail'] == useremail and bcrypt.hashpw(pw_bytes, row['password']) == row['password'] and row['confirmed'] == 1:
						error = "Please confirm your email before login."
					else:
						error = "Username or Password wrong. Please try again or join us now!"

			else:
				error = "Oops! Seems that your are not a hopper! Please join us now!"
		except pymysql.InternalError:
			error = "Error fetching the data. Please try again."
	return render_template('index.html', error=error)

@app.route('/register', methods=['GET','POST'])
def register():
	error = None

	if request.method == 'POST':
		error = validate_registration()

		if error is None:
			hoppa = pymysql.connect(host='br-cdbr-azure-south-a.cloudapp.net', port=3306, user='b15b0d9651d904', passwd='97022638', db='db_hoppa')
			cur = hoppa.cursor()

			#user input data
			userfirst = request.form['fname'].strip()
			usermiddle = request.form['mname'].strip()
			userlast = request.form['lname'].strip()
			user_bdate = request.form['user_bdate'].strip()
			email = request.form['email'].strip()
			user_phone = request.form['user_phone'].strip()
			user_type = request.form['user_type'].strip()
			user_confirmation = 0

			#password hashing
			salt = bcrypt.gensalt()
			passw = request.form['password'].strip()
			pw_bytes = passw.encode('utf-8')
			salt_bytes = salt.encode('utf-8')

			password = bcrypt.hashpw(pw_bytes, salt_bytes) #hashed password

			user_rank = 'Tadpole' #aawwwn
			address_street = request.form['street'].strip()
			address_city = request.form['city'].strip()
			address_state = request.form['state'].strip()
			address_country = request.form['country'].strip()
			address_zipcode = request.form['zipcode'].strip()

			authentication = "SELECT * FROM db_hoppa.hoppers;"

			new_user = "INSERT INTO db_hoppa.hoppers (user_email, user_phone, user_first, user_middle, user_last, user_bdate, user_pass, user_type, user_rank, confirmed) VALUES ('%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%d');" % (email, user_phone, userfirst, usermiddle, userlast, user_bdate, password, user_type, user_rank, user_confirmation)
			print (new_user)
			try:
				cur.execute(authentication)

				data = [dict(userid= row[0], useremail=row[1]) for row in cur.fetchall()]

				is_in = False

				for row in data:
					if row['useremail'] == email:
						is_in = True
				if not is_in:
					cur.execute(new_user)
					hoppa.commit()

					user_address = "INSERT INTO db_hoppa.user_address (street, country, state, zipcode, city, user_addressid) VALUES ('%s', '%s', '%s', '%s', '%s', LAST_INSERT_ID());" % (address_street, address_country, address_state, address_zipcode, address_city)

					cur.execute(user_address)
					hoppa.commit()

					cur.close()
					hoppa.close()

					token = ts.dumps(email, salt=app.config['SECURITY_PASSWORD_SALT'])
					confirm_url = url_for('confirm_email', token=token, _external=True)

					#send welcome email
					subject = userfirst + ", welcome to hoppa!"
					welcome_msg = Message(subject=subject, sender=("Hoppa!", "hoppa.notifications@gmail.com"), recipients=[email])
					welcome_msg.html = render_template("welcomemail.html", confirm_url=confirm_url)
					mail.send(welcome_msg)

					flash("Welcome to Hoppa! Please confirm your email.")
					return redirect(url_for('login'))
				else: 
					error = "User already exists."
			except pymysql.InternalError:
				error = "Error adding the data. Please try again."
			cur.close()
			hoppa.close()
	return render_template('register.html', error=error)

def validate_registration():
		error = None

		userfirst = request.form['fname'].strip()
		userlast = request.form['lname'].strip()
		user_bdate = request.form['user_bdate'].strip()
		email = request.form['email'].strip()
		email_confirmation = request.form['email_c'].strip()
		user_type = request.form['user_type'].strip()
		password = request.form['password'].strip()
		password_confirmation = request.form['password_c'].strip()

		if (not userfirst) and (not userlast) and (not email) and (not password):
			error = "Please fill the required fields."
		if not user_bdate:
			error = "Sorry little tadpole, you cannot access Hoppa right now."
		if email != email_confirmation:
			error = "Emails must match."
		if password != password_confirmation:
			error = "Passwords must match."
		return error

def confirm_token(token, expiration=3600):
    serializer = URLSafeTimedSerializer(app.config['SECRET_KEY'])
    try:
        email = serializer.loads(
            token,
            salt=app.config['SECURITY_PASSWORD_SALT'],
            max_age=expiration
        )
    except:
        return False
    return email

@app.route('/confirm/<token>')
@login_required
def confirm_email(token):
	try:
		email = confirm_token(token)
	except:
		abort(404)

	hoppa = pymysql.connect(host='br-cdbr-azure-south-a.cloudapp.net', port=3306, user='b15b0d9651d904', passwd='97022638', db='db_hoppa')
	cur = hoppa.cursor()

	print email

	get_users = "SELECT * FROM db_hoppa.hoppers WHERE user_email='%s';" % (email)
	confirm_query = "UPDATE db_hoppa.hoppers SET confirmed = 1 WHERE user_email='%s';" % (email)


	try:
		user = cur.execute(get_users)

		user = [dict(userid= row[0], useremail=row[1], confirmed=row[10]) for row in cur.fetchall()]

		for row in user:
			if row['confirmed'] == 1:
				flash('Account already confirmed. Please login.', 'success')
			else:
				cur.execute(confirm_query)
				hoppa.commit()
				flash('You have confirmed your account. Thanks!', 'success')

	except pymysql.InternalError:
		error = "User cannot be reached."
	cur.close()
	hoppa.close()
	return redirect(url_for('login'))

def remove_friends(friendid):

	remove_friend = "DELETE FROM db_hoppa.friends WHERE friend='%s';" % (friendid)

	try:
		cur.execute(remove_friend)
		hoppa.commit()
		return True
	except pymysql.InternalError:
		flash("Friend cannot be removed.")	
	return False

def remove_groups(groupid):
	remove_members = "SELECT * FROM db_hoppa.members WHERE mgroup_id='%s';" % (groupid)

	get_group_data = "SELECT * FROM db_hoppa.groups WHERE group_id='%d'" % (groupid)
	remove_group = "DELETE FROM db_hoppa.groups WHERE group_id='%s';" % (groupid)

	try:
		send_notification("group deleted", group_data)
		cur.execute(get_group_data)
		group_data = [dict(group_id=row[0], group_name=row[1], group_description=row[2], \
						   group_pic=row[3], group_owner=row[4], \
						   group_date=row[5], group_category=row[6]) for row in cur.fetchall()]
		send_notification("group deleted", group_data)

		cur.execute(remove_members)
		hoppa.commit()
		
		cur.execute(remove_group)
		hoppa.commit()
		return True
	except pymysql.InternalError:
		flash("Group cannot be removed.")
	return False

def remove_event(eventid, event_title):
	remove_attendees = "DELETE FROM db_hoppa.attendees WHERE aevent_id='%s';" % (eventid)
	remove_event = "DELETE FROM db_hoppa.events WHERE event_id = '%s';" % (eventid)

	try:
		cur.execute(remove_attendees)
		hoppa.commit()

		cur.execute(remove_event)
		hoppa.commit()

		# subject = event_title + " was removed."
		# remove_msg = Message(subject=subject, sender=("Hoppa!", "hoppa.notifications@gmail.com"), bcc=[theuseremail], recipients=["hoppa.notifications@gmail.com"])
		# remove_msg.body = "The event " + event_title + " was successfully removed."
		# mail.send(remove_msg)

		# flash("Event removed.")
		send_notification("event deleted", object_data={'event_title': event_title, 'event_id': eventid})
		return True
	except pymysql.InternalError:
		flash("Event cannot be removed.")
	return False

def leave_group(groupid):
	leavegroup = "DELETE FROM db_hoppa.members WHERE muser_id = '%s' AND mgroup_id = '%s';" %(theuserid,groupid)

	try:
		cur.execute(leavegroup)
		hoppa.commit()
		flash("You have leave the group.")
		return False
	except pymysql.InternalError:
		flash("Oops! You cannot leave the group. Please try again!")
	return True

def unattend_event(eventid):
	unattendevent = "UPDATE db_hoppa.attendees SET attending=0 WHERE aevent_id='%s' AND auser_id='%s';" % (eventid,theuserid)

	try:
		cur.execute(unattendevent)
		hoppa.commit()
		flash("You are not attending to the event")
		return False
	except pymysql.InternalError:
		flash("Oops! You cannot unattend the event. Please try again!")
	return True

def get_myfriends():
	friends = None

	getfriends = "SELECT * FROM db_hoppa.user_profile JOIN (SELECT * FROM db_hoppa.friends WHERE me='%s') as g WHERE owner_p = friend;" % (theuserid)

	try:
		cur.execute(getfriends)
		friends = [dict(friend_id=row[7], username = row[8], fuser_id=row[10], user_pic = row[5]) for row in cur.fetchall()]
	except pymysql.InternalError:
		flash("You have no friends yet. Please search for people.")
	return friends

def get_friends(user_id):
	friends = None

	getfriends = "SELECT * FROM db_hoppa.friends WHERE me='%d';" % (user_id)

	try:
		cur.execute(getfriends)
		friends = [dict(friend_id=row[0], username = row[1], fuser_id=row[3]) for row in cur.fetchall()]
	except pymysql.InternalError:
		flash("You have no friends yet. Please search for people.")
	return friends

def get_members(groupid):
	members = None

	get_members = "SELECT * FROM db_hoppa.members WHERE mgroup_id='%d';" % (groupid)

	try:
		cur.execute(get_members)

		members = [dict(muser_id=row[2], username = row[1]) for row in cur.fetchall()]
	except pymysql.InternalError:
		flash("There is no members yet.")
	return members

def get_attendees(eventid):
	attendees = None

	get_attendees = "SELECT auser_id,attendee_name,attending, user_email,aevent_id FROM db_hoppa.attendees JOIN db_hoppa.hoppers WHERE db_hoppa.attendees.auser_id = db_hoppa.hoppers.user_id AND db_hoppa.attendees.aevent_id='%s';" % (eventid)

	try:
		cur.execute(get_attendees)

		attendees = [dict(auser_id=row[0], username = row[1], attending=row[2], attendee_email=row[3]) for row in cur.fetchall()]
	except pymysql.InternalError:
		flash("There is no attendees yet.")
	return attendees

def get_mygroups():
	groups = None

	getgroups = "SELECT muser_id, mgroup_id, group_id, group_name FROM db_hoppa.members JOIN db_hoppa.groups WHERE db_hoppa.members.mgroup_id = db_hoppa.groups.group_id AND db_hoppa.members.muser_id='%d';" % (theuserid)

	try:
		cur.execute(getgroups)
		groups = [dict(group_id=row[2], groupname=row[3]) for row in cur.fetchall()]
	except pymysql.InternalError:
		flash("You are not part of any group.")
	return groups

def get_myevents():

	events = None

	getevents = "SELECT event_id, event_title, event_date, auser_id, aevent_id FROM db_hoppa.events JOIN db_hoppa.attendees WHERE db_hoppa.events.event_id = db_hoppa.attendees.aevent_id AND db_hoppa.attendees.auser_id = '%d';" % (theuserid)

	try:
		cur.execute(getevents)
		events = [dict(event_id=row[0], event_title=row[1], event_date=row[2]) for row in cur.fetchall()]
	except pymysql.InternalError:
		flash("You have no events to attend.")
	return events

@app.route('/newsfeed', methods=['GET','POST'])
def newsfeed():
	edit = False
	posts = {'user_first':'','user_last':'','post_description':'','post_date':''}

	get_posts = "SELECT * FROM db_hoppa.user_profile JOIN (SELECT user_first, user_last, user_middle, post_description, post_date, post_owner, post_location, post_media,post_id FROM db_hoppa.posts JOIN db_hoppa.hoppers WHERE db_hoppa.hoppers.user_id = db_hoppa.posts.post_owner) as g WHERE owner_p = g.post_owner AND post_location='newsfeed' ORDER BY post_date DESC;"
	# get_picture = 
	try:
		cur.execute(get_posts)
		posts = [dict(user_pic = row[5], owner_id=row[6], user_first=row[7], user_last=row[8], user_middle=row[9], post_description=row[10], post_datetime=row[11], post_location=row[13], post_media=row[14], post_id=row[15]) for row in cur.fetchall()]

		# friends = get_myfriends()

		# for friend in friends:
			# cur.execute("SELECT * FROM db_hoppa.posts WHERE post_owner='%d';" % (friend['friend_id']))
			# posts.append([dict(owner_id=friend['friend_id'],user_first=row[0], user_last=row[1], post_description=row[2], post_datetime=row[3]) for row in cur.fetchall()])

			#Send notifications to all friends that a post has been made

		# 	cur.execute("SELECT user_email FROM db_hoppa.hoppers WHERE user_id='%d'" % friend['friend_id'])
		# 	friend_email = [dict(friend_email=row[0]) for row in cur.fetchall()]
		# 	subject = theusername + " has posted something"
		# 	post_msg = Message(subject=subject, sender=("Hoppa!", "hoppa.notifications@gmail.com"), bcc=[row['friend_email']], recipients=["hoppa.notifications@gmail.com"])
		# 	post_msg.body = theusername + " has made a post."
		# 	mail.send(post_msg)

	except pymysql.InternalError:
		flash("No posts from friends.")

	if request.method == 'POST':
		postInfo = request.form['posts'].split('_')
		if request.form['posts'] == 'postbutton':
			postmsg = request.form['thepost']
			post_date = datetime.now()
			postquery = "INSERT INTO db_hoppa.posts (post_description, post_date, post_owner, post_location) VALUES ('%s', '%s','%s', 'newsfeed');" % (postmsg, post_date, theuserid)

			try:
				cur.execute(postquery)
				hoppa.commit()

				# cur.execute(get_posts)
				# posts = [dict(owner_id=row[5], user_first=row[0], user_last=row[1], user_middle=row[2], post_description=row[3], post_datetime=row[4], post_location=row[6], post_media=row[7], post_id=row[8],user_picture = row[9]) for row in cur.fetchall()]
				redirect(url_for('newsfeed'))
			except pymysql.InternalError:
				error = "User cannot be reached."
		elif postInfo[0] == 'editbutton':
			edit = True
		elif postInfo[0] == 'savebutton':
			postmsg = request.form['epost']
			postquery = "UPDATE db_hoppa.posts SET post_description = '%s' WHERE post_id='%s';" % (postmsg,postInfo[1])
			try:
				cur.execute(postquery)
				hoppa.commit()

				# cur.execute(get_posts)
				# posts = [dict(owner_id=row[5], user_first=row[0], user_last=row[1], user_middle=row[2], post_description=row[3], post_datetime=row[4], post_location=row[6], post_media=row[7], post_id=row[8]) for row in cur.fetchall()]

				redirect(url_for('newsfeed'))
			except pymysql.InternalError:
				error = "User cannot be reached."
		elif postInfo[0] == 'deletebutton':
			postquery = "DELETE FROM db_hoppa.posts WHERE post_id='%s';" % (postInfo[1])
			try:
				cur.execute(postquery)
				hoppa.commit()

				cur.execute(get_posts)
				posts = [dict(owner_id=row[5], user_first=row[0], user_last=row[1], user_middle=row[2], post_description=row[3], post_datetime=row[4], post_location=row[6], post_media=row[7], post_id=row[8]) for row in cur.fetchall()]

				redirect(url_for('newsfeed'))
			except pymysql.InternalError:
				error = "User cannot be reached."
	return render_template('newsfeed.html', posts = posts, user_id=theuserid, edit=edit)

@app.route('/feedback', methods=['GET','POST'])
def feedback():
	#send feedback email
	if request.method == 'POST':
		username = request.form['username']
		useremail = request.form['useremail']
		usermessage = request.form['usermessage']

		if useremail and username:
			subject = username + " has given Hoppa feedback!"
			feedback_msg = Message(subject=subject, sender=("Hoppa Feedback", "hoppa.notifications@gmail.com"), bcc=[useremail], recipients=["hoppa.notifications@gmail.com"])
			feedback_msg.body = usermessage
			mail.send(feedback_msg)
			flash("We appreciate your time. Thanks for your feedback!")
			return redirect(url_for('login'))
	return render_template('feedback.html')

@app.route('/recovery', methods=['GET','POST'])
def recovery():
	if request.method == 'POST':
		useremail = request.form['useremail']
		if useremail:
			subject = "Password recovery for your Hoppa account."
			recovery_msg = Message(subject=subject, sender=("Hoppa Recovery", "hoppa.notifications@gmail.com"), bcc=[useremail], recipients=["hoppa.notifications@gmail.com"])
			recovery_msg.html = render_template("recoveryemail.html")
			mail.send(recovery_msg)
			flash("An email was sent to you with a recovery link.")
			return redirect(url_for('login'))
	return render_template('recovery.html')

#@app.route('/new_password', methods=['GET','POST'])
#def new_password():
#	error = None
#
#	if request.method == 'POST'
#		hoppa = pymysql.connect(host='us-cdbr-azure-west-c.cloudapp.net', port=3306, user='bb633b141d2f93', passwd='9966c0ab', db='db_hoppa')
#		cur = hoppa.cursor()
#
#		useremail = request.form['useremail']
#		userpassword = request.form['password']
#		userpassword_c = request.form['password_c']
#
#		update_pass = "UPDATE db_hoppa.hoppers SET user_pass='%s' WHERE user_email='%s';" % (password, useremail)
#
#		if userpassword and (userpassword == userpassword_c):
#			#password hashing
#			salt = bcrypt.gensalt()
#			passw = userpassword
#			pw_bytes = passw.encode('utf-8')
#			salt_bytes = salt.encode('utf-8')
#
#			password = bcrypt.hashpw(pw_bytes, salt_bytes)
#
#			try:
#				cur.execute(update_pass)
#				hoppa.commit()
#				hoppa.close()
#				cur.close()
#
#				subject = "Your password has been changed."
#				change_msg = Message(subject=subject, sender=("Hoppa Admin", "hoppa.notifications@gmail.com"), bcc=[useremail], recipients=["hoppa.notifications@gmail.com"])
#				change_msg.body = "Your password has been changed."
#				mail.send(change_msg)
#				flash("Your password has been changed. Please login.")
#				return redirect(url_for('login'))
#			except pymysql.InternalError::
#				error = "Your records are not in our databases."
#
#	return render_template('create_new_password.html', error=error)

#where the list of events the user is going to attend or is invited appears
@app.route('/events')
def myevents():
	return render_template('events.html', events=get_myevents())

#view event information
#where the list of events the user is going to attend or is invited appears
@app.route('/event/<int:eventid>', methods=['GET','POST'])
def event(eventid):
	event_data = None
	isOwner = False
	isAttending = False
	event_title = None

	#Getting event information
	get_eventinfo = "SELECT * FROM db_hoppa.events WHERE event_id='%d';" % (eventid)
	
	try:
		cur.execute(get_eventinfo)

		event_data = [dict(event_id=eventid, event_title=row[1], event_date=row[2], event_description=row[3], event_location=row[4], event_owner=row[5], event_picture=row[6]) for row in cur.fetchall()]
	except pymysql.InternalError:
		flash("There is no event information.")

	for row in event_data:
		if row['event_owner'] == theuserid:
			isOwner = True
		event_title = row['event_title']
	
	if isOwner:
		isAttending = True

	if request.method == 'POST':
		post_location = "event_" + str(eventid)
		actions = request.form['eventaction']
		
		if actions == 'attendbutton':
			isAttending = attend_event(eventid) 
		elif actions  == 'unattendbutton':
			isAttending = unattend_event(eventid)
		elif actions == 'invitebutton':
			return redirect(url_for('friends'))
		elif actions == 'removebutton':
			isAttending = False
			isOwner = False
			remove_event(eventid, event_title)
			return redirect(url_for('myevents'))
		elif actions == 'editbutton':
			return redirect(url_for('eventedit', eventid=eventid))
	return render_template('event.html', event_data=event_data, isOwner=isOwner, isAttending=isAttending)

@app.route('/eventedit/<int:eventid>', methods=['GET', 'POST'])
def eventedit(eventid):
	event_data = None

	get_eventinfo = "SELECT * FROM db_hoppa.events WHERE event_id='%d';" % (eventid)

	try:
		cur.execute(get_eventinfo)

		event_data = [dict(event_title=row[1], event_description=row[3], event_pic=row[6], event_owner=row[5], event_datetime=row[2], event_location=row[4]) for row in cur.fetchall()]
	
	except pymysql.InternalError:
		flash("This event does not exist.")

	if request.method == 'POST':
			event_title = request.form['eventtitle']
			event_description = request.form['eventdesc']
			event_date = request.form['eventdate']
			event_time = request.form['eventtime']
			event_location = request.form['eventlocation']
			event_pic = ""

			event_datetime = event_date + " " + event_time

			#new group query
			edit_event = "UPDATE db_hoppa.events SET event_title = '%s', event_description = '%s', event_date = '%s', event_location = '%s', event_pic = '%s' WHERE event_id= '%s';"  % (event_title, event_description, event_datetime, event_location, event_pic, eventid)
			
			try:
				#adding the new group
				cur.execute(edit_event)
				hoppa.commit()

				# flash("Hooray! The event" + " " + event_title + " " + " was successfully edited.")

				# subject = event_title + " was updated."
				# update_msg = Message(subject=subject, sender=("Hoppa!", "hoppa.notifications@gmail.com"), bcc=[theuseremail], recipients=["hoppa.notifications@gmail.com"])
				# update_msg.body = "Hooray! The event" + " " + event_title + " " + " was successfully edited."
				# mail.send(update_msg)
				send_notification("event edited", event_data)

				return redirect(url_for('myevents'))
			except pymysql.InternalError:
				flash("Oops! The event could not be edited. Please try again!")
	return render_template('eventedit.html', event_data = event_data)

@app.route('/eventposts/<int:eventid>', methods=['GET', 'POST'])
def eventposts(eventid):
	posts = {'user_first':'','user_last':'', 'user_middle':'', 'post_description':'','post_date':''}
	edit = False

	post_location = 'event_' + str(eventid)
	
	#get user posts
	get_posts = "SELECT user_first, user_last, user_middle, post_description, post_date, post_owner, post_location, post_media, post_id FROM db_hoppa.posts JOIN db_hoppa.hoppers WHERE db_hoppa.hoppers.user_id = db_hoppa.posts.post_owner AND db_hoppa.posts.post_location='%s';" % (post_location)
	
	attendees = get_attendees(eventid)

	try:
		cur.execute(get_posts)
		posts = [dict(owner_id=row[5], user_first=row[0], user_last=row[1], user_middle=row[2], post_description=row[3], post_datetime=row[4], post_location=row[6], post_media=row[7], post_id=row[8]) for row in cur.fetchall()]

		get_eventinfo = "SELECT * FROM db_hoppa.events WHERE event_id='%d';" % (eventid)

		cur.execute(get_eventinfo)

		event_data = [dict(event_id=eventid, event_title=row[1], event_date=row[2], event_description=row[3], event_location=row[4], event_owner=row[5], event_picture=row[6]) for row in cur.fetchall()]
	except pymysql.InternalError:
		("No posts to fecth.")

	if request.method == 'POST':
		posts = request.form['posts']
		postInfo = posts.split('_')

		if posts == 'postbutton':
			postmsg = request.form['thepost']
			post_date = datetime.now()
			postquery = "INSERT INTO db_hoppa.posts (post_description, post_date, post_owner, post_location) VALUES ('%s', '%s','%s', '%s');" % (postmsg, post_date, theuserid, post_location)
			send_notification("event post", event_data)

			try:
				cur.execute(postquery)
				hoppa.commit()

				cur.execute(get_posts)
				posts = [dict(owner_id=row[5], user_first=row[0], user_last=row[1], user_middle=row[2], post_description=row[3], post_datetime=row[4], post_location=row[6], post_media=row[7], post_id=row[8]) for row in cur.fetchall()]
				
				for row in attendees:
					subject = "New post from " + row['username'] 
					new_post_msg = Message(subject=subject, sender=("Hoppa!", "hoppa.notifications@gmail.com"), bcc=[row['attendee_email']], recipients=["hoppa.notifications@gmail.com"])
					new_post_msg.body = "One of the attendees has posted on the event profile."
					mail.send(new_post_msg)
				flash("Your data has been posted.")

				redirect(url_for('eventposts', eventid=eventid))
			except pymysql.InternalError:
				flash("User cannot be reached.")
		elif postInfo[0] == 'editpost':
			edit = True
		elif postInfo[0] == 'savebutton':
			postmsg = request.form['epost']
			postquery = "UPDATE db_hoppa.posts SET post_description = '%s' WHERE post_id='%s';" % (postmsg,postInfo[1])
			try:
				cur.execute(postquery)
				hoppa.commit()

				cur.execute(get_posts)
				posts = [dict(owner_id=row[5], user_first=row[0], user_last=row[1], user_middle=row[2], post_description=row[3], post_datetime=row[4], post_location=row[6], post_media=row[7], post_id=row[8]) for row in cur.fetchall()]
				flash("Post updated.")
				redirect(url_for('eventposts', eventid=eventid))
			except pymysql.InternalError:
				flash("User cannot be reached.")
		elif postInfo[0] == 'deletebutton':
			postquery = "DELETE FROM db_hoppa.posts WHERE post_id='%s';" % (postInfo[1])
			try:
				cur.execute(postquery)
				hoppa.commit()

				cur.execute(get_posts)
				posts = [dict(owner_id=row[5], user_first=row[0], user_last=row[1], user_middle=row[2], post_description=row[3], post_datetime=row[4], post_location=row[6], post_media=row[7], post_id=row[8]) for row in cur.fetchall()]
				
				flash("Post deleted.")
				redirect(url_for('eventposts', eventid=eventid))
			except pymysql.InternalError:
				flash("User cannot be reached.")
	return render_template("eventposts.html", posts=posts, user_id=theuserid, edit=edit)

#creating a new event
def validate_new_event():
	event_name = request.form['eventname']
	event_date = request.form['eventdate']
	event_time = request.form['eventtime']
	event_desc = request.form['eventdesc']
	event_location = request.form['eventlocation']

	if not event_name:
		flash("Event name fields is required.")
		return False
	if not event_desc:
		flash("Event description is required.")
		return False
	if not event_location:
		flash("Event location is required.")
		return False
	if not event_date:
		flash("Event date is required.")
		return False
	if not event_time:
		flash("Event time is required.")
		return False

	return True

#implement pic code
@app.route('/addevent', methods=['GET', 'POST'])
def addevent():

	if request.method == 'POST':
		if validate_new_event():

			#input data
			event_name = request.form['eventname']
			event_date = request.form['eventdate']
			event_time = request.form['eventtime']
			event_desc = request.form['eventdesc']
			event_location = request.form['eventlocation']
			event_picture = ""

			event_datetime = event_date + " " + event_time

			#new event query
			new_event = "INSERT INTO db_hoppa.events (event_title, event_date, event_description, event_location, event_pic, event_owner) VALUES ('%s','%s', '%s', '%s','%s','%d');"  % (event_name, event_datetime, event_desc, event_location, event_picture, theuserid)
			
			try:
				#adding the new event
				cur.execute(new_event)
				hoppa.commit()

				attending = 1

				#adding owner as a attendee
				event_attendee = "INSERT INTO db_hoppa.attendees (attendee_name, auser_id, aevent_id, attending) VALUES ('%s', '%d', LAST_INSERT_ID(), '%d');" % (theusername,theuserid,attending)
				cur.execute(event_attendee)
				hoppa.commit()

				#cur.close()
				#hoppa.close()

				#send welcome email
				# subject = event_name + " was successfully created."
				# event_created_msg = Message(subject=subject, sender=("Hoppa!", "hoppa.notifications@gmail.com"), recipients=[theuseremail])
				# event_created_msg.body = "Hooray! The event" + " " + event_name + " " + " was successfully created."
				# mail.send(event_created_msg)
				# flash("Hooray! The event" + " " + event_name + " " + " was successfully created.")
				send_notification("created event", event_name)


				return redirect(url_for('myevents'))
			except pymysql.InternalError:
				flash("Oops! The event could not be created. Please try again!")
	return render_template('addevent.html')

# Check; add html to display info
#where the list of groups the hopper belongs appears
@app.route('/groups', methods=['GET', 'POST'])
def mygroups():
	#hoppa = pymysql.connect(host='br-cdbr-azure-south-a.cloudapp.net', port=3306, user='b15b0d9651d904', passwd='97022638', db='db_hoppa')
	#cur = hoppa.cursor()

	get_groupinfo = "SELECT * FROM db_hoppa.groups JOIN (SELECT mgroup_id FROM db_hoppa.members WHERE muser_id = '%s') AS g GROUP BY group_id;" % (theuserid)
	print(get_groupinfo)
	try:
		cur.execute(get_groupinfo)

		group_data = [dict(group_id=row[0], group_name=row[1], group_description=row[2], \
						   group_pic=row[3], group_owner=row[4], \
						   group_date=row[5], group_category=row[6]) for row in cur.fetchall()]
	except pymysql.InternalError:
				flash("Oops! The group could not be created. Please try again!")
	return render_template('groups.html', group_data = group_data)

# Check; add html to display info
#view group information
@app.route('/group/<int:groupid>', methods=['GET', 'POST'])
def group(groupid):
	error = None
	edit = False
	group_info = None

	get_groupinfo = "SELECT * FROM db_hoppa.groups WHERE group_id='%d';" % (groupid)
	get_postsinfo = "SELECT * FROM (SELECT * FROM db_hoppa.posts JOIN db_hoppa.hoppers) AS g JOIN db_hoppa.groups WHERE post_location='group_%s' AND post_owner = user_id GROUP BY post_id;" % (groupid)
	get_isMember = "SELECT * FROM db_hoppa.members WHERE muser_id='%d' and mgroup_id = '%d';" % (theuserid, groupid)
	get_isOwner = "SELECT * FROM db_hoppa.groups WHERE group_owner='%d' AND group_id = '%s';" %(theuserid, groupid)

	try:
		cur.execute(get_groupinfo)

		group_data = [dict(group_name=row[1], group_description=row[2], \
						   group_pic=row[3], group_owner=row[4], \
						   group_date=row[5], group_category=row[6]) for row in cur.fetchall()]
		cur.execute(get_postsinfo)

		group_posts = [dict(post_id= row[0], post_desc=row[1], post_date=row[2], \
						   post_owner=row[4], post_owner_name=row[9]+ ' ' + row[11]+ ' ' + row[10]) for row in cur.fetchall()]

		isMember = cur.execute(get_isMember)
		isOwner = cur.execute(get_isOwner)
		if isMember == 0 or isMember == 'None':
			isMember = False
		else: isMember = True
		if isOwner == 0:
			isOwner = False
		else: isOwner = True

	except pymysql.InternalError:
		flash("This group does not exist.")
	if request.method == 'POST':
		postInfo = request.form['gbutton'].split('_')
		print(request.form['gbutton'])
		if request.form['gbutton'] == 'join':
			isMember = join_group(groupid)
		elif request.form['gbutton'] == 'leave':
			isMember = leave_group(groupid)
		elif request.form['gbutton'] == 'edit':
			print (group_data)
			return redirect(url_for('editgroup', groupid = groupid))
		elif request.form['gbutton'] == 'members':
			return redirect(url_for('members', groupid=groupid))
		elif request.form['gbutton'] == 'invite':
			return redirect(url_for('friends')) #temporary
		elif request.form['gbutton'] == 'close':
			if isMember:
				remove_groups(groupid)
		elif request.form['gbutton'] == 'post':
			desc = request.form['gpost']
			post_date = datetime.now()
			post = "INSERT INTO db_hoppa.posts (post_description, post_date, post_owner, post_location) VALUES ('%s','%s', '%s', 'group_%s');" %(desc,post_date,theuserid,groupid)
			send_notification("group post", group_data)

			try:
				cur.execute(post)
				hoppa.commit()
			except pymysql.InternalError:
				flash("This group does not exist.")

		elif postInfo[0] == 'editbutton':
			edit = True
		elif postInfo[0] == 'savebutton':
			postmsg = request.form['epost']
			postquery = "UPDATE db_hoppa.posts SET post_description = '%s' WHERE post_id='%s';" % (postmsg,postInfo[1])
			try:
				cur.execute(postquery)
				hoppa.commit()

			except pymysql.InternalError:
				error = "User cannot be reached."
		elif postInfo[0] == 'deletebutton':
			postquery = "DELETE FROM db_hoppa.posts WHERE post_id='%s';" % (postInfo[1])
			try:
				cur.execute(postquery)
				hoppa.commit()

			except pymysql.InternalError:
				flash("This group does not exist.")

	return render_template('group.html', group_posts = group_posts ,group_data=group_data, isMember = isMember, isOwner = isOwner, user_id = theuserid, edit = edit)

#creating a new group
def validate_new_group():
	group_name = request.form['groupname']
	group_desc = request.form['groupdesc']
	group_category = request.form['groupcat']

	if not group_name:
		flash("Group name is required.")
		return False
	if not group_desc:
		flash("Group description is required.")
		return False
	if not group_category:
		flash("Group category is required.")
		return False
	return True

#implement pic code
@app.route('/addgroup', methods=['GET', 'POST'])
def addgroup():

	if request.method == 'POST':
		if validate_new_group():

			#input data
			group_name = request.form['groupname']
			group_description = request.form['groupdesc']
			group_category = request.form['groupcat']

			#new group query
			new_group = "INSERT INTO db_hoppa.groups (group_name, group_description, group_owner, group_date, group_category) VALUES ('%s','%s', '%d',NOW(), '%s');"  % (group_name, group_description, theuserid, group_category)
			
			try:
				#adding the new group
				cur.execute(new_group)
				hoppa.commit()

				#adding owner as a member
				group_member = "INSERT INTO db_hoppa.members (member_name, muser_id, mgroup_id) VALUES ('%s', '%d', LAST_INSERT_ID());" % (theusername,theuserid)
				
				cur.execute(group_member)
				hoppa.commit()

				#cur.close()
				#hoppa.close()

				#send welcome email
				# subject = group_name + " was successfully created."
				# group_created_msg = Message(subject=subject, sender=("Hoppa!", "hoppa.notifications@gmail.com"), recipients=[theuseremail])
				# group_created_msg.body = "Hooray! The group" + " " + group_name + " " + "was successfully created."
				# mail.send(group_created_msg)
				# flash("Hooray! The group" + " " + group_name + " " + " was successfully created.")

				send_notification("created group", group_name)

				return redirect(url_for('mygroups'))
			except pymysql.InternalError:
				flash("Oops! The group could not be created. Please try again!")
	return render_template('addgroup.html')

def send_notification(notification, object_data):
	if "created" in notification:
		if notification == "group created": # Generates notifications about creating groups and events
			description = "Hooray! The group " + object_data['group_name'] + " was successfully created."
			subject = object_data['group_name'] + " was successfully created."
			flash("Hooray! The group " + object_data['group_name'] + " was successfully created.")
		elif notification == "event created":
			description = "Hooray! The event " + object_data['event_title'] + " was successfully created."
			subject = object_data['event_title'] + " was successfully created."
			flash("Hooray! The event " + object_data['event_title'] + " was successfully created.")

		group_created_msg = Message(subject=subject, sender=("Hoppa!", "hoppa.notifications@gmail.com"), recipients=[theuseremail])
		group_created_msg.body = description
		mail.send(group_created_msg)

		create_notification = "INSERT INTO db_hoppa.notifications " \
							"(not_user, notification_date, notification_description) " \
							"VALUES ('%d', '%s', '%s')" % (theuserid, datetime.now(), description)
		try:
			cur.execute(create_notification)
		except pymysql.InternalError:
			flash("Something went wrong while generating a group notification.")


	elif "invite" in notification: # Generates notificatoins about group and event invites
		print("Doing nothing for now")


	elif "group" in notification: # Generates notifications about joining groups, posts in groups, group edition, and group deletion
		group_data = object_data
		get_owner_info = "SELECT user_id, user_email " \
						 "FROM db_hoppa.hoppers NATURAL JOIN db_hoppa.groups " \
						 "WHERE user_id=group_owner AND group_id='%d'" % group_data['group_id']

		if notification == "join group":
			description = theusername + " has joined your group: " + group_data['group_name'] + "!"
			subject = theusername + " has joined " + group_data['group_name']

		elif notification == "group post":
			description = theusername + " has posted something in your group: " + group_data['group_name'] + "."
			subject = theusername + " has posted in " + group_data['group_name']

		elif notification == "group edited":
			description = "You have edited the following group: " + group_data['group_name'] + "."
			subject = "You have edited a group"

		elif notification == "group deleted":
			description = "You have deleted the following group: " + group_data['group_name'] + "."
			subject = "You have deleted a group"
		try:
			cur.execute(get_owner_info)
			owner_data = [dict(owner_id=row[0], owner_email=row[1]) for row in cur.fetchall()]
		except pymysql.InternalError:
			flash("Something went wrong while obtaining group owner data.")
		
		email = owner_data['owner_email']
		group_msg = Message(subject=subject, sender=("Hoppa!", "hoppa.notifications@gmail.com"), bcc=[email], recipients=["hoppa.notifications@gmail.com"])
		group_msg.body = description
		mail.send(group_msg)

		create_notification = "INSERT INTO db_hoppa.notifications " \
							"(not_user, notification_date, notification_description) " \
							"VALUES ('%d', '%s', '%s')" % (owner_info['owner_id'], datetime.now(), description)
		try:
			cur.execute(create_notification)
		except pymysql.InternalError:
			flash("Something went wrong while generating a group notification.")


	elif "event" in notification: # Generates notifications about joining events, posts in events, event edition, and event deletion
		event_data = object_data
		get_owner_info = "SELECT user_id, user_email " \
						 "FROM db_hoppa.hoppers NATURAL JOIN db_hoppa.events " \
						 "WHERE user_id=event_owner AND group_id='%d'" % event_data['eventid']

		if notification == "attend event":
			description = theusername + " will be attending your " + event_data['event_title'] + " event."
			subject = theusername + " will attend " + event_data['event_title']

		elif notification == "event post":
			description = theusername + " has posted something in your " + event_data['event_title'] + " event."
			subject = theusername + " has posted in " + event_data['event_title']

		elif notification == "event edited":
			description = "You have edited the following event: " + event_data['event_title'] + "."
			subject = "You have edited an event"

		elif notification == "event deleted":
			description = "You have deleted the following event: " + event_data['event_title'] + "."
			subject = "You have deleted an event"
		try:
			cur.execute(get_owner_info)
			owner_info = [dict(owner_id=row[0], owner_email=row[1]) for row in cur.fetchall()]
		except pymysql.InternalError:
			flash("Something went wrong while obtaining event owner data.")

			email = owner_info['owner_email']
			attending_msg = Message(subject=subject, sender=("Hoppa!", "hoppa.notifications@gmail.com"), bcc=[email], recipients=["hoppa.notifications@gmail.com"])
			attending_msg.body = description
			mail.send(attending_msg)

			create_notification = "INSERT INTO db_hoppa.notifications " \
								  "(not_user, notification_date, notification_description) " \
								  "VALUES ('%d', '%s', '%s')" % (owner_info['owner_id'], datetime.now(), description)
			cur.execute(create_notification)
		except pymysql.InternalError:
			flash("Something went wrong while generating event notifications.")


	elif notification == "added friend": # Generates notifications on adding a friend and sends email
		try:
			friend_data = object_data
			get_friend_info = "SELECT user_email " \
							  "FROM db_hoppa.hoppers" \
							  "WHERE user_id='%d'" % friend_data['friendid']
			cur.execute(get_friend_info)
			for row in cur.fetchall():
				email = row[0]

			description = theusername + " added you as a friend."
			subject = "You are now friends with " + theusername
			friend_msg = Message(subject=subject, sender=("Hoppa!", "hoppa.notifications@gmail.com"), bcc=[email], recipients=["hoppa.notifications@gmail.com"])
			friend_msg.body = description
			mail.send(friend_msg)

			create_notification = "INSERT INTO db_hoppa.notifications " \
								  "(not_user, notification_date, notification_description) " \
								  "VALUES ('%d', '%s', '%s')" % (friend_data['friend_id'], datetime.now(), description)
			cur.execute(create_notification)
		except pymysql.InternalError:
			flash("Something went wrong while generating friend notifications.")
	return

def join_group(groupid):
	join = "INSERT INTO db_hoppa.members (member_name, muser_id, mgroup_id) VALUES ('%s', '%s', '%s');" % (theusername, theuserid, groupid)
	get_groupdata = "SELECT * FROM db_hoppa.groups WHERE group_id='%s';" % (groupid)
	try:
		cur.execute(join)
		hoppa.commit()

		cur.execute(get_groupdata)
		# Changed
		group_data = [dict(groupname=row[1], group_id=groupid) for row in cur.fetchall()]

		#send group joined email
		# for row in group_data:
		# 	subject = "You are now part of " + row['groupname']
		# 	joined_msg = Message(subject=subject, sender=("Hoppa!", "hoppa.notifications@gmail.com"), bcc=[theuseremail], recipients=["hoppa.notifications@gmail.com"])
		# 	joined_msg.body = "Congratulations! Now you are part of " + row['groupname']
		# 	mail.send(joined_msg)
		# flash("Hop. You've Joined!!")

		send_notification("join group", group_data)

		#Send notification to owner that user has joined group
		# cur.execute(get_owner_email)
		# owner_email = [dict(owner_email=row[0]) for row in cur.fetchall()]

		# subject = theusername + " has joined " + group_data['groupname']
		# join_msg = Message(subject=subject, sender=("Hoppa!", "hoppa.notifications@gmail.com"), bcc=[owner_email], recipients=["hoppa.notifications@gmail.com"])
		# join_msg.body = theusername + " has joined your group: " + group_data['groupname'] + "."
		# mail.send(join_msg)



		return True
	except pymysql.InternalError:
		flash("Could not join group.")
	return False
	
def attend_event(eventid):
	attending = 1

	attend = "INSERT INTO db_hoppa.attendees (attendee_name, auser_id, aevent_id, attending) VALUES ('%s', '%s', '%s', '%s');" % (theusername, theuserid, eventid, attending)
	get_eventdata = "SELECT * FROM db_hoppa.events WHERE event_id ='%s';" % (eventid)

	try:
		cur.execute(attend)
		hoppa.commit()

		cur.execute(get_eventdata)
		# Changed
		event_data = [dict(eventtitle=row[1], event_id=eventid) for row in cur.fetchall()]

		#send attending email
		for row in event_data:
			subject = "You are attending " + row['eventtitle']
			attend_msg = Message(subject=subject, sender=("Hoppa!", "hoppa.notifications@gmail.com"), bcc=[theuseremail], recipients=["hoppa.notifications@gmail.com"])
			attend_msg.body = "Congratulations! Now you are attending " + row['eventtitle']
			mail.send(attend_msg)
			flash("You are attending to " + row['eventtitle'])

		#Send notification email that someone will attend the event
		# cur.execute(get_owner_email)
		# owner_email = [dict(owner_email=row[0]) for row in cur.fetchall()]

		# subject = theusername + " will attend " + event_data['eventtitle']
		# attending_msg = Message(subject=subject, sender=("Hoppa!", "hoppa.notifications@gmail.com"), bcc=[owner_email], recipients=["hoppa.notifications@gmail.com"])
		# attending_msg.body = theusername + " will be attending " + event_data['eventtitle'] + "."
		# mail.send(attending_msg)

		send_notification("attend event", event_data)

		return True
	except pymysql.InternalError:
		flash("Could not join group.")
	return False

def add_friend(friendid):
	get_friend_data = "SELECT user_first, user_last, user_middle, user_email FROM db_hoppa.hoppers WHERE user_id='%s';" % (friendid)

	try:
		cur.execute(get_friend_data)
		# Changed
		friend_data = [dict(email=row[3], ffirst=row[0], fmiddle=row[2], flast=row[1], friend_id=friendid) for row in cur.fetchall()]

		for row in friend_data:
			friend_name = row['ffirst'] + " " + row['fmiddle'] + " " + row['flast']
			friend_email = row['email']

		add_friend = "INSERT INTO db_hoppa.friends (friend_name, me, friend) VALUES ('%s', '%s', '%s');" % (friend_name, theuserid, friendid)

		cur.execute(add_friend)
		hoppa.commit()

		#send added as friend email
		# subject = "You and " + theusername + " are now friends!"
		# added_msg = Message(subject=subject, sender=("Hoppa!", "hoppa.notifications@gmail.com"), bcc=[friend_email], recipients=["hoppa.notifications@gmail.com"])
		# added_msg.body = theusername + " added you as a friend."
		# mail.send(added_msg)

		send_notification("added friend", friend_data)

		flash("You and " + friend_name + " are now friends.")

		return True
	except pymysql.InternalError:
		flash("Could not add friend.")
	return False

@app.route('/editgroup/<int:groupid>', methods=['GET', 'POST'])
def editgroup(groupid):

	get_groupinfo = "SELECT * FROM db_hoppa.groups WHERE group_id='%d';" % (groupid)

	try:
		cur.execute(get_groupinfo)

		group_data = [dict(group_name=row[1], group_description=row[2], \
						   group_pic=row[3], group_owner=row[4], \
						   group_date=row[5], group_category=row[6]) for row in cur.fetchall()]
	except pymysql.InternalError:
		flash("This group does not exist.")

	if request.method == 'POST':
			print(request.form['groupname'])
			group_name = request.form['groupname']
			group_description = request.form['groupdesc']

			#new group query
			edit_group = "UPDATE db_hoppa.groups SET group_name = '%s', group_description = '%s' WHERE group_id= '%s';"  % (group_name, group_description, groupid)
			
			try:
				#adding the new group
				cur.execute(edit_group)
				hoppa.commit()

				flash("Hooray! The group" + " " + group_name + " " + " was successfully edited.")

				subject = group_name + " was updated."
				update_msg = Message(subject=subject, sender=("Hoppa!", "hoppa.notifications@gmail.com"), bcc=[theuseremail], recipients=["hoppa.notifications@gmail.com"])
				update_msg.body = "Hooray! The group " + " " + group_name + " " + " was successfully edited."
				mail.send(update_msg)

				return redirect(url_for('mygroups'))
			except pymysql.InternalError:
				flash("Oops! The group could not be created. Please try again!")
	return render_template('editgroup.html', group_data = group_data)

#user profile
@app.route('/myprofile', methods=['GET', 'POST'])
def myprofile():
	error = None
	user_data = None
	user_education = None

	#Displaying the information
	get_myinfo = "SELECT * FROM db_hoppa.user_profile WHERE owner_p='%d';" % (theuserid)
	get_education = "SELECT * FROM db_hoppa.education WHERE eduser_id='%d';" % (theuserid)
	
	try:
		cur.execute(get_myinfo)

		user_data = [dict(user_id=theuserid, user_name=theusername, user_about= row[1], user_interests=row[2], user_associations=row[3], user_courses=row[4], user_picture=row[5], user_rank=theuserrank) for row in cur.fetchall()]
		print(user_data)
		cur.execute(get_education)

		user_education= [dict(school=row[1], major=row[2], user_id=theuserid) for row in cur.fetchall()]
	except pymysql.InternalError:
		flash("There is no user information.")
	
	#Updating the information
	if request.method == 'POST':
		print(request.form['buttons'])

		if request.form['buttons'] =='upload':
			profile_pic_dir = upload_file()
			print(profile_pic_dir)
			update_mypic = "UPDATE db_hoppa.user_profile SET profile_pic='%s' WHERE owner_p='%s';" % (profile_pic_dir,theuserid)
			
			try:
				cur.execute(update_mypic)
				hoppa.commit()
				return redirect('myprofile')

				flash("Successfully updated your photo.")
			except pymysql.InternalError:
				flash("Cannot update your information.")
		else:
			about = request.form['about']
			interests = request.form['interests']
			school = request.form['school']
			major = request.form['major']
			associations = request.form['associations']
			courses = request.form['courses']

			try:
				cur.execute(update_myinfo)
				hoppa.commit()

				cur.execute(update_myeducation)
				hoppa.commit()

				flash("Successfully updated your info.")

				subject = "Your profile information was updated."
				update_msg = Message(subject=subject, sender=("Hoppa!", "hoppa.notifications@gmail.com"), bcc=[theuseremail], recipients=["hoppa.notifications@gmail.com"])
				update_msg.body = "Congratulations! Your profile information was successfully updated."
				mail.send(update_msg)
			except pymysql.InternalError:
				flash("Cannot update your information.")
	return render_template('myprofile.html', user_data=user_data, user_education=user_education, usertype=theusertype)

@app.route('/myfriend/<int:friendid>', methods=['GET', 'POST'])
def myfriendprofile(friendid):
	friend_data = None
	friend_education = None

	if friendid == theuserid:
		return redirect(url_for('myprofile'))
	else:
		#get friend data
		get_username = "SELECT * FROM db_hoppa.hoppers WHERE user_id='%s';" % (friendid)
		get_friendinfo = "SELECT * FROM db_hoppa.user_profile WHERE owner_p='%s';" % (friendid)
		get_friendedu = "SELECT * FROM db_hoppa.education WHERE eduser_id='%s';" % (friendid)

		try:
			cur.execute(get_username)

			username = [dict(firstname=row[3], middlename=row[5], lastname=row[4], userrank=row[9]) for row in cur.fetchall()]
			for row in username:
				user_name = row['firstname'] + " " + row['middlename'] + " " + row['lastname']
				user_rank = row['userrank']

			cur.execute(get_friendinfo)
			friend_data = [dict(user_id=row[6], user_name=user_name, user_about= row[1], user_interests=row[2], user_associations=row[3], user_courses=row[4], user_picture=row[5], user_rank=user_rank) for row in cur.fetchall()]
			
			cur.execute(get_friendedu)
			friend_education = [dict(school=row[1], major=row[2], user_id=row[3]) for row in cur.fetchall()]
		except pymysql.InternalError:
			flash("Cannot get friend profile data.")

		if request.method == 'POST':
			action = request.form['manage'].split('_')
			if action[0] == 'addbutton':
				add_friend(action[1])
				flash("You are now friends.")
			elif action[0] == 'removebutton':
				remove_friends(action[1])
				flash("You are no longer friends.")
			elif action[0] == 'rankbutton':
				return redirect(url_for('message')) #Add something
			elif action[0] == 'messagebutton':
				return redirect(url_for('message'))
	return render_template('friendprofile.html', friend_data=friend_data, friend_education=friend_education)

@app.route('/members/<int:groupid>')
def members(groupid):
	return render_template('members.html', members=get_members(groupid))

@app.route('/attendees/<int:eventid>')
def attendees(eventid):
	return render_template('attendees.html', attendees=get_attendees(eventid))

@app.route('/friends')
def friends():
	return render_template('friends.html', friends=get_myfriends())


@app.route('/settings', methods=['GET', 'POST'])
def settings():
	
	#Displaying the information
	get_myinfo = "SELECT * FROM db_hoppa.hoppers WHERE user_id='%s';" % (theuserid)
	get_education = "SELECT * FROM db_hoppa.user_address WHERE user_addressid='%s';" % (theuserid)
	
	try:
		cur.execute(get_myinfo)

		user_data = [dict(user_id=theuserid, user_phone=row[2], user_first= row[3], user_last=row[4], user_middle=row[5]) for row in cur.fetchall()]
		
		cur.execute(get_education)

		user_address= [dict(street=row[1], country=row[2], state=row[3],zipcode=row[4], city=row[5]) for row in cur.fetchall()]
	except pymysql.InternalError:
		flash("There is no user information.")

	if request.method == 'POST':
		print(request.form['sButton'])
		if request.form['sButton'] == 'pass':
			#password hashing
			salt = bcrypt.gensalt()
			passw = request.form['password'].strip()
			password_confirmation = request.form['password_c'].strip()

			if passw != password_confirmation:
				flash("Passwords must match.")
				return render_template('settings.html', user_data = user_data, user_address = user_address)

			pw_bytes = passw.encode('utf-8')
			salt_bytes = salt.encode('utf-8')
	
			password = bcrypt.hashpw(pw_bytes, salt_bytes) #hashed password
			
			

			new_pass = "UPDATE db_hoppa.hoppers SET user_pass='%s' WHERE user_id = '%s';" % (password, theuserid)
			print (new_pass)
			try:

				cur.execute(new_pass)
				hoppa.commit()


				flash("Your password have been changed.")
			except pymysql.InternalError:
				error = "Error adding the data. Please try again."

		elif request.form['sButton'] == 'save':
		
			#user input data
			userfirst = request.form['fname'].strip()
			usermiddle = request.form['mname'].strip()
			userlast = request.form['lname'].strip()
			user_phone = request.form['user_phone'].strip()

			address_street = request.form['street'].strip()
			address_city = request.form['city'].strip()
			address_state = request.form['state'].strip()
			address_country = request.form['country'].strip()
			address_zipcode = request.form['zipcode'].strip()

			edit_user = "UPDATE db_hoppa.hoppers SET user_phone = '%s', user_first = '%s', user_middle = '%s', user_last = '%s' WHERE user_id = '%s';" % (user_phone, userfirst, usermiddle, userlast, theuserid)
			print (edit_user)
			try:

				cur.execute(edit_user)
				hoppa.commit()

				euser_address = "UPDATE db_hoppa.user_address SET street = '%s', country = '%s', state = '%s', zipcode = '%s', city = '%s' WHERE user_addressid = '%s';" % (address_street, address_country, address_state, address_zipcode, address_city, theuserid)
				print(euser_address)
				cur.execute(euser_address)
				hoppa.commit()

				flash("Your settings have been saved.")
			except pymysql.InternalError:
				error = "Error adding the data. Please try again."
		elif request.form['sButton'] == 'delete':
			delete_user = "DELETE FROM db_hoppa.hoppers WHERE user_id = '%s';" % (theuserid)
			
			try:

				cur.execute(delete_user)
				hoppa.commit()

				flash("Goodbye.")
			except pymysql.InternalError:
				error = "Error adding the data. Please try again."
			return render_template('login.html')
	return render_template('settings.html', user_data = user_data, user_address = user_address)

@app.route('/logout')
@login_required
def logout():
	session.pop('logged_in', None)
	cur.close()
	hoppa.close()
	flash("Hope to see you back soon!")
	return redirect(url_for('home'))

@app.route('/search', methods=['POST'])
def search():
	if request.method == 'POST':
		data = request.form['search']
		return redirect(url_for('results', data=data))
	return redirect(url_for('newsfeed'))

@app.route('/results/<data>', methods=['GET', 'POST'])
def results(data):

	# Getting results for search
	search_users = "SELECT * FROM db_hoppa.hoppers WHERE user_first LIKE '%s' OR user_last LIKE '%s' OR user_middle LIKE '%s'" % (data,data,data)
	search_groups = "SELECT * FROM db_hoppa.groups WHERE group_name LIKE '%s';" % (data)
	search_events = "SELECT * FROM db_hoppa.events WHERE event_title LIKE '%s';" % (data)

	try:
		cur.execute(search_users)

		friends_results = [dict(userfirst=row[3], userlast=row[4], usermiddle=row[5], friendid=row[0]) for row in cur.fetchall()]

		cur.execute(search_groups)

		groups_results = ([dict(groupname=row[1], groupid=row[0]) for row in cur.fetchall()])

		cur.execute(search_events)

		events_results = ([dict(eventtitle=row[1], eventid=row[0]) for row in cur.fetchall()])

		myfriends = get_myfriends()
		mygroups= get_mygroups()
		myevents = get_myevents()

		message = "Search results."
	except pymysql.InternalError:
		message = "Unable to search for results."

	#Adding, joining or attending 
	if request.method == 'POST':
		result_data = request.form['results'].split('_')

		if result_data[0] == 'joinbutton':
			join_group(result_data[1])
		elif result_data[0] == 'attendbutton':
			attend_event(result_data[1])
		elif result_data[0] == 'addbutton':
			add_friend(result_data[1])
		return redirect(url_for('results', data=data))
	return render_template("results.html", friends_results=friends_results, groups_results=groups_results, events_results=events_results, message=message, friends=myfriends, events=myevents, groups=mygroups)


if __name__ == '__main__':
	socketio.run(app)